<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autonomous Driving Simulator - Computational Thinking Practice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #2a3c7a);
            color: #fff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        header {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 28px;
            margin-bottom: 10px;
            color: #4fc3f7;
        }
        
        .subtitle {
            font-size: 16px;
            opacity: 0.8;
        }
        
        .content {
            display: flex;
            min-height: 600px;
        }
        
        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .main-content {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        .ct-steps {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }
        
        .ct-step {
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 4px solid transparent;
        }
        
        .ct-step.active {
            background: rgba(79, 195, 247, 0.2);
            border-left: 4px solid #4fc3f7;
        }
        
        .ct-step:hover {
            transform: translateX(5px);
        }
        
        .step-number {
            display: inline-block;
            width: 25px;
            height: 25px;
            background: #4fc3f7;
            border-radius: 50%;
            text-align: center;
            line-height: 25px;
            margin-right: 10px;
            font-weight: bold;
        }
        
        .simulation-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .parking-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 3px;
            background: #1a237e;
            padding: 15px;
            border-radius: 10px;
            position: relative;
        }
        
        .grid-cell {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s;
        }
        
        .grid-cell.entrance {
            background: #00c853;
            color: white;
            font-weight: bold;
        }
        
        .grid-cell.parking-spot {
            background: #2962ff;
            color: white;
            font-weight: bold;
        }
        
        .grid-cell.obstacle {
            background: #d50000;
            color: white;
            font-weight: bold;
        }
        
        .grid-cell.path {
            background: #ffd600;
            color: #000;
        }
        
        .grid-cell.current {
            background: #ff9800;
            color: white;
        }
        
        .car {
            width: 80%;
            height: 80%;
            background: #ff6d00;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.5s ease;
        }
        
        .car.east { transform: rotate(0deg); }
        .car.south { transform: rotate(90deg); }
        .car.west { transform: rotate(180deg); }
        .car.north { transform: rotate(270deg); }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background: #4fc3f7;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            font-weight: bold;
        }
        
        button:hover {
            background: #29b6f6;
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #78909c;
            cursor: not-allowed;
            transform: none;
        }
        
        button.reset {
            background: #f44336;
        }
        
        button.reset:hover {
            background: #d32f2f;
        }
        
        .command-blocks {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .command-block {
            padding: 8px 12px;
            background: #7e57c2;
            color: white;
            border-radius: 5px;
            cursor: grab;
            user-select: none;
            font-size: 14px;
            transition: all 0.3s;
            border: 2px solid transparent;
        }
        
        .command-block:hover {
            background: #673ab7;
            transform: scale(1.05);
        }
        
        .command-block.dragging {
            opacity: 0.5;
            border: 2px dashed #4fc3f7;
        }
        
        .algorithm-area {
            min-height: 100px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: flex-start;
            transition: all 0.3s;
        }
        
        .algorithm-area.drag-over {
            border-color: #4fc3f7;
            background: rgba(79, 195, 247, 0.1);
        }
        
        .algorithm-step {
            padding: 8px 12px;
            background: #00c853;
            color: white;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
            animation: popIn 0.3s ease;
        }
        
        .algorithm-step.executing {
            background: #ff9800;
            animation: pulse 1s infinite;
        }
        
        .algorithm-step.executed {
            background: #4caf50;
        }
        
        .algorithm-step.failed {
            background: #f44336;
        }
        
        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .remove-step {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 12px;
            padding: 0;
            width: 16px;
            height: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .status {
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            margin-top: 10px;
            font-size: 14px;
            min-height: 50px;
            display: flex;
            align-items: center;
        }
        
        .success {
            color: #00c853;
            font-weight: bold;
        }
        
        .failure {
            color: #ff5252;
            font-weight: bold;
        }
        
        h2 {
            margin-bottom: 15px;
            color: #4fc3f7;
            font-size: 22px;
        }
        
        h3 {
            margin: 15px 0 10px 0;
            color: #bb86fc;
            font-size: 18px;
        }
        
        p {
            margin-bottom: 10px;
            line-height: 1.5;
            font-size: 14px;
        }
        
        .instruction-text {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .step-content {
            display: none;
        }
        
        .step-content.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .visual-demo {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .demo-item {
            flex: 1;
            min-width: 200px;
            text-align: center;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
        }
        
        .demo-icon {
            font-size: 40px;
            margin-bottom: 10px;
            color: #4fc3f7;
        }
        
        .execution-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .execution-controls button {
            flex: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Autonomous Driving Simulator: Computational Thinking Practice</h1>
            <div class="subtitle">Master the four steps of computational thinking through interactive learning</div>
        </header>
        
        <div class="content">
            <div class="sidebar">
                <h2>Computational Thinking Steps</h2>
                <div class="instruction-text">
                    <p>Follow these four steps to learn how to break down complex problems and design solutions.</p>
                </div>
                
                <div class="ct-steps">
                    <div class="ct-step active" data-step="1">
                        <span class="step-number">1</span>
                        <strong>Decomposition</strong> - Break big problems into smaller ones
                    </div>
                    <div class="ct-step" data-step="2">
                        <span class="step-number">2</span>
                        <strong>Pattern Recognition</strong> - Discover patterns in data
                    </div>
                    <div class="ct-step" data-step="3">
                        <span class="step-number">3</span>
                        <strong>Abstraction</strong> - Ignore details, focus on essentials
                    </div>
                    <div class="ct-step" data-step="4">
                        <span class="step-number">4</span>
                        <strong>Algorithm</strong> - Design step-by-step solutions
                    </div>
                </div>
                
                <div class="step-content active" id="step-1">
                    <h3>Decomposition: Simplify Complexity</h3>
                    <p>Autonomous driving may seem complex, but we can break it down into three main subsystems:</p>
                    <ul>
                        <li><strong>Perception System</strong> - How the vehicle "sees" its environment</li>
                        <li><strong>Decision System</strong> - How the vehicle "thinks" and makes decisions</li>
                        <li><strong>Control System</strong> - How the vehicle "executes" commands</li>
                    </ul>
                </div>
                
                <div class="step-content" id="step-2">
                    <h3>Pattern Recognition: Discover Patterns</h3>
                    <p>Autonomous vehicles need to recognize various patterns on the road:</p>
                    <ul>
                        <li>Lane marking patterns</li>
                        <li>Traffic signal patterns</li>
                        <li>Obstacle patterns</li>
                        <li>Other vehicle behavior patterns</li>
                    </ul>
                </div>
                
                <div class="step-content" id="step-3">
                    <h3>Abstraction: Focus on Essentials</h3>
                    <p>Extract key information from complex reality:</p>
                    <ul>
                        <li>Abstract vehicles as points</li>
                        <li>Abstract roads as grids</li>
                        <li>Abstract obstacles as geometric shapes</li>
                        <li>Ignore unnecessary details like colors and textures</li>
                    </ul>
                </div>
                
                <div class="step-content" id="step-4">
                    <h3>Algorithm: Step-by-Step Solutions</h3>
                    <p>Design clear instruction sequences:</p>
                    <ul>
                        <li>If an obstacle is detected, navigate around it</li>
                        <li>If reaching an intersection, act according to signals</li>
                        <li>Always maintain safe distance</li>
                        <li>Finally reach the target position</li>
                    </ul>
                </div>
            </div>
            
            <div class="main-content">
                <h2>Autonomous Parking Simulator</h2>
                
                <div class="simulation-area">
                    <div class="controls">
                        <button id="runSimulation">Run Simulation</button>
                        <button id="stepSimulation">Step Forward</button>
                        <button id="resetSimulation" class="reset">Reset Simulation</button>
                        <button id="clearAlgorithm">Clear Algorithm</button>
                    </div>
                    
                    <div class="parking-grid" id="parkingGrid">
                        <!-- Grid will be dynamically generated by JavaScript -->
                    </div>
                    
                    <h3>Available Commands</h3>
                    <div class="command-blocks" id="commandBlocks">
                        <div class="command-block" draggable="true" data-command="forward1">Move Forward 1</div>
                        <div class="command-block" draggable="true" data-command="forward2">Move Forward 2</div>
                        <div class="command-block" draggable="true" data-command="forward3">Move Forward 3</div>
                        <div class="command-block" draggable="true" data-command="turnLeft">Turn Left</div>
                        <div class="command-block" draggable="true" data-command="turnRight">Turn Right</div>
                        <div class="command-block" draggable="true" data-command="checkObstacle">Check Obstacle</div>
                        <div class="command-block" draggable="true" data-command="wait">Wait</div>
                    </div>
                    
                    <h3>Your Algorithm <span style="font-size: 14px; font-weight: normal;">(Drag commands here)</span></h3>
                    <div class="algorithm-area" id="algorithmArea">
                        <!-- Algorithm steps will be displayed here -->
                    </div>
                    
                    <div class="status" id="status">
                        Ready to design your first autonomous driving algorithm...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Parking layout definition
        const parkingLayout = {
            entrance: { x: 0, y: 4 },
            parkingSpot: { x: 9, y: 4 },
            obstacles: [
                { x: 3, y: 2 }, { x: 3, y: 3 }, { x: 3, y: 4 },
                { x: 6, y: 5 }, { x: 6, y: 6 }, { x: 7, y: 6 }
            ]
        };

        // Car state
        let carState = {
            x: parkingLayout.entrance.x,
            y: parkingLayout.entrance.y,
            direction: 'east', // east, south, west, north
            path: [],
            currentStep: 0,
            isRunning: false
        };

        // Initialize parking grid
        function initializeParkingGrid() {
            const grid = document.getElementById('parkingGrid');
            grid.innerHTML = '';
            
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 10; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    // Mark special cells
                    if (x === parkingLayout.entrance.x && y === parkingLayout.entrance.y) {
                        cell.classList.add('entrance');
                        cell.innerHTML = '<div>Entrance</div>';
                    } else if (x === parkingLayout.parkingSpot.x && y === parkingLayout.parkingSpot.y) {
                        cell.classList.add('parking-spot');
                        cell.innerHTML = '<div>Parking Spot</div>';
                    } else if (parkingLayout.obstacles.some(obs => obs.x === x && obs.y === y)) {
                        cell.classList.add('obstacle');
                        cell.innerHTML = '<div>Obstacle</div>';
                    }
                    
                    grid.appendChild(cell);
                }
            }
            
            // Place car at entrance
            placeCar(carState.x, carState.y, carState.direction);
        }

        // Place car
        function placeCar(x, y, direction = 'east') {
            // Remove existing car
            const existingCar = document.querySelector('.car');
            if (existingCar) {
                existingCar.remove();
            }
            
            // Find target cell and place car
            const targetCell = document.querySelector(`.grid-cell[data-x="${x}"][data-y="${y}"]`);
            if (targetCell) {
                const car = document.createElement('div');
                car.className = `car ${direction}`;
                car.innerHTML = 'Car';
                targetCell.appendChild(car);
                
                // Update car state
                carState.x = x;
                carState.y = y;
                carState.direction = direction;
            }
        }

        // Step switching
        function setupStepSwitcher() {
            const steps = document.querySelectorAll('.ct-step');
            
            steps.forEach(step => {
                step.addEventListener('click', () => {
                    // Remove all active classes
                    steps.forEach(s => s.classList.remove('active'));
                    document.querySelectorAll('.step-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // Add active class to current step
                    step.classList.add('active');
                    const stepId = `step-${step.dataset.step}`;
                    document.getElementById(stepId).classList.add('active');
                });
            });
        }

        // Fixed drag and drop functionality
        function setupDragAndDrop() {
            const commandBlocks = document.querySelectorAll('.command-block');
            const algorithmArea = document.getElementById('algorithmArea');
            
            // Set drag events for each command block
            commandBlocks.forEach(block => {
                block.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', block.dataset.command);
                    block.classList.add('dragging');
                    setTimeout(() => {
                        block.style.display = 'none';
                    }, 0);
                });
                
                block.addEventListener('dragend', (e) => {
                    block.classList.remove('dragging');
                    block.style.display = 'block';
                });
            });
            
            // Algorithm area drag and drop events
            algorithmArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                algorithmArea.classList.add('drag-over');
            });
            
            algorithmArea.addEventListener('dragleave', (e) => {
                // Only remove style when mouse leaves algorithm area
                if (!algorithmArea.contains(e.relatedTarget)) {
                    algorithmArea.classList.remove('drag-over');
                }
            });
            
            algorithmArea.addEventListener('drop', (e) => {
                e.preventDefault();
                algorithmArea.classList.remove('drag-over');
                
                const command = e.dataTransfer.getData('text/plain');
                addCommandToAlgorithm(command);
                
                // Restore command block display
                commandBlocks.forEach(block => {
                    block.style.display = 'block';
                    block.classList.remove('dragging');
                });
            });
        }

        // Add command to algorithm area
        function addCommandToAlgorithm(command) {
            const algorithmArea = document.getElementById('algorithmArea');
            const commandText = getCommandText(command);
            
            const step = document.createElement('div');
            step.className = 'algorithm-step';
            step.dataset.command = command;
            step.innerHTML = `
                ${commandText}
                <button class="remove-step">×</button>
            `;
            
            // Add remove functionality
            step.querySelector('.remove-step').addEventListener('click', () => {
                step.remove();
                updateStatus('Command removed: ' + commandText);
            });
            
            algorithmArea.appendChild(step);
            updateStatus('Command added: ' + commandText);
        }

        // Get display text based on command
        function getCommandText(command) {
            const commandMap = {
                'forward1': 'Move Forward 1',
                'forward2': 'Move Forward 2',
                'forward3': 'Move Forward 3',
                'turnLeft': 'Turn Left',
                'turnRight': 'Turn Right',
                'checkObstacle': 'Check Obstacle',
                'wait': 'Wait'
            };
            return commandMap[command] || command;
        }

        // Update status information
        function updateStatus(message, isSuccess = true) {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = 'status ' + (isSuccess ? 'success' : 'failure');
        }

        // Check if a position is valid (within grid and not an obstacle)
        function isValidPosition(x, y) {
            // Check boundaries
            if (x < 0 || x >= 10 || y < 0 || y >= 8) {
                return false;
            }
            
            // Check obstacles
            if (parkingLayout.obstacles.some(obs => obs.x === x && obs.y === y)) {
                return false;
            }
            
            return true;
        }

        // Calculate next position based on current position and direction
        function calculateNextPosition(x, y, direction, steps = 1) {
            let newX = x;
            let newY = y;
            
            switch (direction) {
                case 'east':
                    newX += steps;
                    break;
                case 'south':
                    newY += steps;
                    break;
                case 'west':
                    newX -= steps;
                    break;
                case 'north':
                    newY -= steps;
                    break;
            }
            
            return { x: newX, y: newY };
        }

        // Execute a single command
        function executeCommand(command) {
            const algorithmSteps = document.querySelectorAll('.algorithm-step');
            const currentStep = algorithmSteps[carState.currentStep];
            
            // Mark current step as executing
            currentStep.classList.add('executing');
            
            let success = true;
            let message = '';
            
            switch (command) {
                case 'forward1':
                case 'forward2':
                case 'forward3':
                    const steps = parseInt(command.replace('forward', ''));
                    const newPos = calculateNextPosition(carState.x, carState.y, carState.direction, steps);
                    
                    if (isValidPosition(newPos.x, newPos.y)) {
                        // Check if path is clear
                        let pathClear = true;
                        for (let i = 1; i <= steps; i++) {
                            const intermediatePos = calculateNextPosition(carState.x, carState.y, carState.direction, i);
                            if (!isValidPosition(intermediatePos.x, intermediatePos.y)) {
                                pathClear = false;
                                break;
                            }
                        }
                        
                        if (pathClear) {
                            carState.x = newPos.x;
                            carState.y = newPos.y;
                            carState.path.push({x: carState.x, y: carState.y});
                            message = `Moved forward ${steps} step(s)`;
                        } else {
                            success = false;
                            message = `Path blocked! Cannot move forward ${steps} step(s)`;
                        }
                    } else {
                        success = false;
                        message = `Invalid position! Cannot move forward ${steps} step(s)`;
                    }
                    break;
                    
                case 'turnLeft':
                    const leftTurns = { east: 'north', north: 'west', west: 'south', south: 'east' };
                    carState.direction = leftTurns[carState.direction];
                    message = 'Turned left';
                    break;
                    
                case 'turnRight':
                    const rightTurns = { east: 'south', south: 'west', west: 'north', north: 'east' };
                    carState.direction = rightTurns[carState.direction];
                    message = 'Turned right';
                    break;
                    
                case 'checkObstacle':
                    const aheadPos = calculateNextPosition(carState.x, carState.y, carState.direction, 1);
                    const obstacleAhead = !isValidPosition(aheadPos.x, aheadPos.y);
                    message = obstacleAhead ? 'Obstacle detected ahead!' : 'Path is clear ahead';
                    break;
                    
                case 'wait':
                    message = 'Waiting...';
                    break;
            }
            
            // Update car position and direction
            placeCar(carState.x, carState.y, carState.direction);
            
            // Mark step as executed or failed
            currentStep.classList.remove('executing');
            if (success) {
                currentStep.classList.add('executed');
                updateStatus(message, true);
            } else {
                currentStep.classList.add('failed');
                updateStatus(message, false);
                carState.isRunning = false;
                document.getElementById('runSimulation').disabled = false;
                document.getElementById('stepSimulation').disabled = false;
            }
            
            return success;
        }

        // Run simulation with logical path planning
        function runSimulation() {
            const algorithmSteps = document.querySelectorAll('.algorithm-step');
            if (algorithmSteps.length === 0) {
                updateStatus('Please add some commands to the algorithm area first', false);
                return;
            }
            
            // Reset simulation state
            carState = {
                x: parkingLayout.entrance.x,
                y: parkingLayout.entrance.y,
                direction: 'east',
                path: [],
                currentStep: 0,
                isRunning: true
            };
            
            // Clear previous path
            document.querySelectorAll('.grid-cell.path, .grid-cell.current').forEach(cell => {
                cell.classList.remove('path', 'current');
            });
            
            // Reset car position
            placeCar(carState.x, carState.y, carState.direction);
            
            // Reset step highlighting
            algorithmSteps.forEach(step => {
                step.classList.remove('executing', 'executed', 'failed');
            });
            
            // Disable run button during execution
            document.getElementById('runSimulation').disabled = true;
            document.getElementById('stepSimulation').disabled = false;
            
            updateStatus('Starting simulation with logical path planning...');
            
            // Execute commands sequentially
            executeStepByStep();
        }

        // Execute commands one by one
        function executeStepByStep() {
            const algorithmSteps = document.querySelectorAll('.algorithm-step');
            
            if (carState.currentStep >= algorithmSteps.length || !carState.isRunning) {
                // Simulation complete
                carState.isRunning = false;
                document.getElementById('runSimulation').disabled = false;
                document.getElementById('stepSimulation').disabled = true;
                
                // Check if car reached parking spot
                if (carState.x === parkingLayout.parkingSpot.x && carState.y === parkingLayout.parkingSpot.y) {
                    updateStatus('✓ Algorithm successful! Vehicle has safely parked.', true);
                } else {
                    updateStatus('Simulation completed but vehicle did not reach parking spot.', false);
                }
                
                return;
            }
            
            const command = algorithmSteps[carState.currentStep].dataset.command;
            const success = executeCommand(command);
            
            if (success) {
                carState.currentStep++;
                
                // Visualize path
                visualizePath();
                
                // Continue to next step after delay
                if (carState.isRunning) {
                    setTimeout(executeStepByStep, 1000);
                }
            }
        }

        // Step forward one command
        function stepForward() {
            const algorithmSteps = document.querySelectorAll('.algorithm-step');
            
            if (algorithmSteps.length === 0) {
                updateStatus('Please add some commands to the algorithm area first', false);
                return;
            }
            
            if (!carState.isRunning) {
                // Start new simulation
                carState = {
                    x: parkingLayout.entrance.x,
                    y: parkingLayout.entrance.y,
                    direction: 'east',
                    path: [],
                    currentStep: 0,
                    isRunning: true
                };
                
                // Clear previous path
                document.querySelectorAll('.grid-cell.path, .grid-cell.current').forEach(cell => {
                    cell.classList.remove('path', 'current');
                });
                
                // Reset car position
                placeCar(carState.x, carState.y, carState.direction);
                
                // Reset step highlighting
                algorithmSteps.forEach(step => {
                    step.classList.remove('executing', 'executed', 'failed');
                });
                
                // Disable run button during execution
                document.getElementById('runSimulation').disabled = true;
                document.getElementById('stepSimulation').disabled = false;
                
                updateStatus('Starting step-by-step execution...');
            }
            
            if (carState.currentStep < algorithmSteps.length && carState.isRunning) {
                const command = algorithmSteps[carState.currentStep].dataset.command;
                const success = executeCommand(command);
                
                if (success) {
                    carState.currentStep++;
                    visualizePath();
                    
                    // Check if simulation completed
                    if (carState.currentStep >= algorithmSteps.length) {
                        carState.isRunning = false;
                        document.getElementById('runSimulation').disabled = false;
                        document.getElementById('stepSimulation').disabled = true;
                        
                        // Check if car reached parking spot
                        if (carState.x === parkingLayout.parkingSpot.x && carState.y === parkingLayout.parkingSpot.y) {
                            updateStatus('✓ Algorithm successful! Vehicle has safely parked.', true);
                        } else {
                            updateStatus('Simulation completed but vehicle did not reach parking spot.', false);
                        }
                    } else {
                        updateStatus('Ready for next step. Click "Step Forward" to continue.', true);
                    }
                }
            }
        }

        // Visualize path
        function visualizePath() {
            // Clear previous path
            document.querySelectorAll('.grid-cell.path').forEach(cell => {
                cell.classList.remove('path');
            });
            
            // Mark all visited cells as path
            carState.path.forEach(point => {
                const cell = document.querySelector(`.grid-cell[data-x="${point.x}"][data-y="${point.y}"]`);
                if (cell && !cell.classList.contains('entrance') && 
                    !cell.classList.contains('parking-spot') && 
                    !cell.classList.contains('obstacle')) {
                    cell.classList.add('path');
                }
            });
            
            // Highlight current position
            const currentCell = document.querySelector(`.grid-cell[data-x="${carState.x}"][data-y="${carState.y}"]`);
            if (currentCell) {
                currentCell.classList.add('current');
            }
        }

        // Reset simulation
        function resetSimulation() {
            carState = {
                x: parkingLayout.entrance.x,
                y: parkingLayout.entrance.y,
                direction: 'east',
                path: [],
                currentStep: 0,
                isRunning: false
            };
            
            // Clear path visualization
            document.querySelectorAll('.grid-cell.path, .grid-cell.current').forEach(cell => {
                cell.classList.remove('path', 'current');
            });
            
            // Reset car position
            placeCar(carState.x, carState.y, carState.direction);
            
            // Reset step highlighting
            document.querySelectorAll('.algorithm-step').forEach(step => {
                step.classList.remove('executing', 'executed', 'failed');
            });
            
            // Enable buttons
            document.getElementById('runSimulation').disabled = false;
            document.getElementById('stepSimulation').disabled = false;
            
            updateStatus('Simulation reset. Ready to design new algorithm...');
        }

        // Clear algorithm
        function clearAlgorithm() {
            const algorithmArea = document.getElementById('algorithmArea');
            algorithmArea.innerHTML = '';
            updateStatus('Algorithm cleared. Ready to start over.');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initializeParkingGrid();
            setupStepSwitcher();
            setupDragAndDrop();
            
            // Add button event listeners
            document.getElementById('runSimulation').addEventListener('click', runSimulation);
            document.getElementById('stepSimulation').addEventListener('click', stepForward);
            document.getElementById('resetSimulation').addEventListener('click', resetSimulation);
            document.getElementById('clearAlgorithm').addEventListener('click', clearAlgorithm);
        });
    </script>
</body>
</html>
